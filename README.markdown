# SipFSM

SipFSM - SIP application development in Ruby using SimpleFSM, a simple and lightweight domain specific language (DSL).

## Installation

Install SipFSM gem as any other JRuby gem:

      $ jruby -S gem install sipfsm

## Features and usage

You can read about SipFSM and SimpleFSM in our papers. PDF files are available at [this location](http://scholar.google.com/citations?user=7RoQiiQAAAAJ).

SipFSM is based on SimpleFSM DSL (simplefsm Ruby gem). Besides that, it works best with jrubycipango JRuby gem. See further instructions on jrubycipango Github page.

### The idea
To better organize the code for the SIP application logic,
the SimpleFSM DSL can be utilized inside a SIP servlet
class implemented in Ruby.

For this purpose, the Ruby SipFSM class was developed as a subclass of Java SipServlet class (`javax.servlet.sip.SipServlet`). It includes the `SimpleFSM` module and some minor modifications in the base class to effectively utilize the `SimpleFSM` module and simplify the SIP servlet development. The idea is to define the concrete SIP application logic using the FSM meta-language inside the Ruby SIP controller class, a subclass of the `SipFSM` class. The FSM inside the controller class is manipulated as a consequence of events generated by the JEE server after receiving SIP messages.

## Events 

The FSM events that represent the received SIP messages are specified in the format `sipXXX`, where `XXX` represents the SIP request method extracted from the message, in case the received message is a SIP request. Similarly, a `sipRESPONSE_YYY` event, where `YYY` represents a SIP response code or SIP response code class, is used to notify the FSM that a SIP response message was received. Futhermore, the FSM can accept events `sipREQUEST_ANY` and `sipRESPONSE_ANY` if it is required to process any received request and/or response inside a certain application state. Examples of events that can be handled by the FSM inside the Ruby SIP controller are: 

  - `sipINVITE` - for INVITE request,
  - `sipACK` - for ACK request,
  - `sipCANCEL` - for CANCEL request,
  - `sipRESPONSE_200` - for SIP response with code `'200 (OK)'`,
  - `sipRESPONSE_2xx` - for any SIP responses with code begining with 2 (success responses),
  - `sipREQUEST_ANY` - for any SIP request,
  - `sipRESPONSE_ANY` - for any SIP response.

The application's FSM, while in some state, can react, for example,  to `sipRESPONSE_1xx` events, which represent all informational responses. While in another state, the FSM can react distinguishing between the events `sipRESPONSE_180`, `sipRESPONSE_183` or `sipRESPONSE_1xx`, as shown in the following listing: 

      transitions_for :state1 do
        event :sipRESPONSE_1xx, :new => :state1, 
            :do => :action1
        event :sipRESPONSE_ANY, :new => :state12
      end

      transitions_for :state2 do
        event :sipRESPONSE_1xx, :new => state2, 
            :do => :action2
        event :sipRESPONSE_180, :new => state2, 
            :do => :action3
        event :sipRESPONSE_183, :new => state2, 
            :do => :action4
        event :sipRESPONSE_ANY, :new => :state22, 
            :do => :action5
      end

The FSM facility considers the current application state and generates an event that is the most specific to the message it receives.  If, for example, the FSM receives a response message `180 Ringing` while in `:state1`, then the most specific event to generate is the `sipRESPONSE_1xx` event. Similarly, when the application is in `:state2`, the `180` response message would result in generation of the `sipRESPONSE_180` event, the `182 Queued` message would result in generation of the `sipRESPONSE_1xx` event, while any other received SIP response message would result in generation of the `sipRESPONSE_ANY` event. 


More help end examples are to come.




